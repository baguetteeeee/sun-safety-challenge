<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mela vs UV Villain</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background: #f0f8ff;
    margin: 0;
    padding: 20px 0;
  }

  /* Health UI */
  .health-wrap {
    width: 360px;
    margin: 6px auto 12px;
    text-align: left;
  }
  .health-wrap .label {
    font-weight: 600;
    margin-bottom: 4px;
  }
  .bar {
    height: 18px;
    background: #eee;
    border: 2px solid #333;
    border-radius: 10px;
    overflow: hidden;
  }
  .fill {
    height: 100%;
    width: 100%;
    background: linear-gradient(to right, #2ecc71, #27ae60);
    transition: width 0.25s linear;
  }

  /* Game area */
  #gameArea {
    position: relative;
    width: 640px;
    height: 460px;
    margin: 10px auto 16px;
    border: 2px solid #333;
    background: #fff; /* white inside */
    overflow: hidden;
  }

  /* Images: centered, not squashed */
  #mela, #villain {
    position: absolute;
    width: 140px;
    height: auto;      /* keep aspect ratio */
    left: 50%;
    transform: translateX(-50%);
    user-select: none;
    pointer-events: none;
  }
  #villain { top: 8px; }
  #mela    { bottom: 0px; } /* a bit lower, per your request */

  /* UV ray */
  .ray {
    position: absolute;
    width: 10px;
    height: 54px;
    background: orange;
    left: 50%;
    transform: translateX(-50%);
  }

  /* Controls & messages */
  #buttons { margin-top: 8px; }
  button {
    padding: 10px 14px;
    margin: 0 8px 8px;
    font-size: 16px;
    cursor: pointer;
  }
  #message {
    margin-top: 6px;
    font-weight: bold;
    min-height: 24px;
  }

  /* Certificate */
  #certificateCanvas {
    margin: 18px auto 0;
    display: none;
    border: 1px solid #333;
    max-width: 95%;
  }
</style>
</head>
<body>

<h1>Mela vs UV Villain</h1>

<!-- UV health -->
<div class="health-wrap">
  <div class="label">UV Villain</div>
  <div class="bar"><div id="uvFill" class="fill"></div></div>
</div>

<div id="gameArea">
  <img id="villain" src="https://st2.depositphotos.com/3250055/8394/v/950/depositphotos_83944362-stock-illustration-evil-cartoon-sun.jpg" alt="UV Villain" />
  <img id="mela"    src="https://heyclipart.com/cdn/shop/files/2-mole-in-hole-vector-cartoon-illustration-42.jpg" alt="Mela" />
</div>

<!-- Mela health -->
<div class="health-wrap">
  <div class="label">Mela</div>
  <div class="bar"><div id="melaFill" class="fill"></div></div>
</div>

<div id="buttons"></div>
<div id="message"></div>

<canvas id="certificateCanvas" width="800" height="500"></canvas>

<script>
  // ======== Game state ========
  const MAX_HP = 5;
  let uvHP = MAX_HP;
  let melaHP = MAX_HP;

  const uvFill = document.getElementById('uvFill');
  const melaFill = document.getElementById('melaFill');
  const buttonsDiv = document.getElementById('buttons');
  const messageEl = document.getElementById('message');
  const gameArea = document.getElementById('gameArea');

  // Ray animation state (with requestAnimationFrame)
  let activeRay = null; // {el, y, state: 'falling'|'bouncing', lastT}
  let spawner = null;

  // Options: exactly one correct each round
  const correctOptions = ["Sunscreen", "Hat", "Shade", "Sunglasses"];
  const wrongOptionsPool = [
    "Wear short sleeves", "Jump in a puddle", "Eat ice cream",
    "Dance in the sun", "Cover eyes with hands", "Sit on the grass", "Drink water"
  ];

  // ======== UI helpers ========
  function updateHealthBars() {
    uvFill.style.width = (uvHP / MAX_HP * 100) + '%';
    melaFill.style.width = (melaHP / MAX_HP * 100) + '%';
  }
  function showMessage(text, color) {
    messageEl.textContent = text;
    messageEl.style.color = color || '#000';
  }
  function setButtons() {
    buttonsDiv.innerHTML = '';
    const correct = correctOptions[Math.floor(Math.random() * correctOptions.length)];
    const opts = [correct];
    while (opts.length < 3) {
      const pick = wrongOptionsPool[Math.floor(Math.random() * wrongOptionsPool.length)];
      if (!opts.includes(pick)) opts.push(pick);
    }
    opts.sort(() => Math.random() - 0.5);
    opts.forEach(opt => {
      const btn = document.createElement('button');
      btn.textContent = opt; // NO ticks; you must choose the right one :)
      btn.addEventListener('click', () => protect(opt, correct));
      buttonsDiv.appendChild(btn);
    });
  }

  // ======== Ray logic (RAF, no glitches) ========
  const FALL_SPEED = 180;   // px/sec
  const BOUNCE_SPEED = 320; // px/sec
  const RAY_TOP = 110;      // start Y
  const RAY_TOP_LIMIT = 6;  // when bouncing reaches top
  function startRay() {
    if (activeRay) return;
    const el = document.createElement('div');
    el.className = 'ray';
    el.style.top = RAY_TOP + 'px';
    gameArea.appendChild(el);

    activeRay = { el, y: RAY_TOP, state: 'falling', lastT: performance.now() };
    requestAnimationFrame(stepRay);
  }
  function stepRay(now) {
    if (!activeRay) return; // removed
    const dt = Math.min(50, now - activeRay.lastT) / 1000; // cap big jumps
    activeRay.lastT = now;

    if (activeRay.state === 'falling') {
      activeRay.y += FALL_SPEED * dt;
      activeRay.el.style.top = activeRay.y + 'px';

      const hitY = gameArea.clientHeight - 80; // near Mela's head
      if (activeRay.y >= hitY) {
        // FALL HIT
        removeRay();
        melaHP = Math.max(0, melaHP - 1);
        updateHealthBars();
        showMessage('UV hit Mela! ðŸ˜¢', 'red');
        checkGameOverOrContinue();
        return;
      }
    } else if (activeRay.state === 'bouncing') {
      activeRay.y -= BOUNCE_SPEED * dt;
      activeRay.el.style.top = activeRay.y + 'px';
      if (activeRay.y <= RAY_TOP_LIMIT) {
        // BOUNCE REACHED TOP -> UV takes damage
        removeRay();
        uvHP = Math.max(0, uvHP - 1);
        updateHealthBars();
        showMessage('Blocked the UV ray! ðŸ˜Ž', 'green');
        checkGameOverOrContinue();
        return;
      }
    }

    requestAnimationFrame(stepRay);
  }
  function removeRay() {
    if (!activeRay) return;
    const el = activeRay.el;
    if (el && el.parentNode) el.parentNode.removeChild(el);
    activeRay = null;
  }

  // Answer handling
  function protect(selected, correct) {
    if (!activeRay) return;
    // stop falling instantly to prevent "hit" after success
    if (activeRay.state === 'falling' && selected === correct) {
      activeRay.state = 'bouncing';
      activeRay.el.style.background = 'red'; // turns red immediately and goes back up
      return;
    }
    if (selected !== correct) {
      // wrong: immediate hit
      removeRay();
      melaHP = Math.max(0, melaHP - 1);
      updateHealthBars();
      showMessage('Wrong choice! UV got through! ðŸ˜¢', 'red');
      checkGameOverOrContinue();
    }
  }

  // Game flow
  function checkGameOverOrContinue() {
    if (uvHP <= 0) {
      stopSpawner();
      buttonsDiv.innerHTML = '';
      showMessage('Mela defeated the UV Villain! ðŸŽ‰', 'blue');
      generateCertificate();
    } else if (melaHP <= 0) {
      stopSpawner();
      buttonsDiv.innerHTML = '';
      showMessage('Mela got defeated! ðŸ˜¢', 'red');
    } else {
      setButtons();
    }
  }
  function startSpawner() {
    setButtons();
    if (spawner) clearInterval(spawner);
    // spawn first ray after a moment, then every 2.8s
    setTimeout(startRay, 800);
    spawner = setInterval(startRay, 2800);
  }
  function stopSpawner() {
    if (spawner) clearInterval(spawner);
    spawner = null;
    removeRay();
  }

  // ======== Certificate with upward-curved, upright letters ========
  function generateCertificate() {
    const name = prompt("Congratulations! Enter your name for the certificate:");
    if (!name) return;

    const canvas = document.getElementById('certificateCanvas');
    const ctx = canvas.getContext('2d');
    canvas.style.display = 'block';

    const img = new Image();
    img.crossOrigin = 'anonymous'; // try to allow canvas draw (depends on host headers)
    img.src = 'https://iili.io/KJag612.md.png';

    img.onload = function() {
      const cw = canvas.width, ch = canvas.height;
      const iw = img.width, ih = img.height;
      const scale = Math.min(cw / iw, ch / ih);
      const drawW = iw * scale, drawH = ih * scale;
      const dx = (cw - drawW) / 2;
      const dy = (ch - drawH) / 2 + 10; // nudge down a little

      // clear + draw image centered, not squashed
      ctx.clearRect(0, 0, cw, ch);
      ctx.drawImage(img, dx, dy, drawW, drawH);

      // text settings
      let fontSize = 38; // tweak to fit banner
      ctx.font = `bold ${fontSize}px Arial`;
      ctx.fillStyle = 'black';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // center of the arc: roughly 1/3 from bottom of the drawn image
      const centerX = cw / 2;
      const centerY = dy + drawH * (2 / 3); // 1/3 from bottom
      const radius = Math.min(drawW, drawH) * 0.34; // adjust to match banner curve
      const letterSpacing = 2.0; // px of extra spacing so letters donâ€™t squish

      drawTextOnArcUpright(ctx, name, centerX, centerY, radius, letterSpacing);
    };
  }

  // Curve letters along an upward arc but keep each letter upright (not sideways).
  function drawTextOnArcUpright(ctx, text, cx, cy, radius, letterSpacingPx) {
  // Measure total width including spacing
  const widths = text.split('').map(ch => ctx.measureText(ch).width);
  const totalWidth = widths.reduce((a,b) => a+b, 0) + letterSpacingPx*(text.length-1);

  let startX = cx - totalWidth/2;
  for (let i = 0; i < text.length; i++) {
    const charWidth = widths[i];
    ctx.fillText(text[i], startX + charWidth/2, cy);
    startX += charWidth + letterSpacingPx;
  }
  }

  // ======== Init ========
  updateHealthBars();
  startSpawner();
</script>
</body>
</html>
